#include "compression.h"
#include "math.h"
#include "stdlib.h"
#include "stdio.h"
#include "huff.h"
#include "tables.h"
#include "utils.h"
#include "config.h"

/* File and buffer static variables*/
static FILE *fptr;
static uint16_t buf;
static uint8_t nbit;

/* Private function prototypes */
void prv_array_to_matrix(float **matrix, const float *arr, int matrix_num);
void prv_compress_block(float **Matrix, uint8_t channel, enum Type_t type);
void prv_block_dct(float **Matrix, int N, int M);
void prv_rgb_to_ycbcr(uint8_t *mcu_array);
void prv_quantize(float **Matrix, enum Type_t type);
void prv_huffman_encode(float **Matrix, uint8_t channel, enum Type_t type);

void compression_init(){
    /* Generate all huffman codes */
    generate_huff_codes(&huffman_tables[LUM_DC_TABLE], LUM_DC_TABLE);
    generate_huff_codes(&huffman_tables[LUM_AC_TABLE], LUM_AC_TABLE);
    generate_huff_codes(&huffman_tables[COL_DC_TABLE], COL_DC_TABLE);
    generate_huff_codes(&huffman_tables[COL_AC_TABLE], COL_AC_TABLE);

    /* Initialize file and write buffer */
    buf = 0;
    nbit = 0;
    fptr = fopen(FILE_OUT,"wb");
}

void compress_MCU(uint8_t *mcu_array){
    float **channels_mat = calloc_mat(3, BLOCK_SIZE*BLOCK_SIZE);

    float **Y_mat = calloc_mat(BLOCK_SIZE, BLOCK_SIZE);
    float **Cb_mat = calloc_mat(BLOCK_SIZE, BLOCK_SIZE);
    float **Cr_mat = calloc_mat(BLOCK_SIZE, BLOCK_SIZE);


    /* START OF PROBLEM CHILD
     * I think I'm just stupid but I tried to put this in the function and for the life of me I don't know why
     * it wasn't returning the correct mcu_array (passed by reference) but this is just copied logic from there */
    //    prv_rgb_to_ycbcr(mcu_array);
    static uint8_t tmp_arr[BLOCK_SIZE*BLOCK_SIZE*IMG_CHANNELS] = { 0 };

    for(unsigned char *p = mcu_array, *pg = tmp_arr; p != mcu_array + (BLOCK_SIZE*BLOCK_SIZE*IMG_CHANNELS); p += IMG_CHANNELS, pg += IMG_CHANNELS) {
        *pg       = (uint8_t)( 0.257   * *p + 0.504  * *(p + 1) + 0.098   * *(p + 2)) + 16;          // Y
        *(pg + 1) = (uint8_t)(-0.148   * *p - 0.291  * *(p + 1) + 0.439   * *(p + 2)) + 128;         // Cb
        *(pg + 2) = (uint8_t)( 0.439   * *p - 0.368  * *(p + 1) - 0.071   * *(p + 2)) + 128;         // Cr
    }

    mcu_array = &tmp_arr[0];
    /* END OF PROBLEM CHILD */

    int index = 0;
    for(unsigned char *p = mcu_array; p != mcu_array + BLOCK_SIZE*BLOCK_SIZE*IMG_CHANNELS; p += IMG_CHANNELS, index++) {
        channels_mat[0][index] = *p;     // Y
        channels_mat[1][index] = *(p+1); // Cb
        channels_mat[2][index] = *(p+2); // Cr
    }

    enum Type_t types[3] = {LUM, COL, COL};
    prv_array_to_matrix(Y_mat, &channels_mat[0][0], 0);
    prv_array_to_matrix(Cb_mat, &channels_mat[1][0], 0);
    prv_array_to_matrix(Cr_mat, &channels_mat[2][0], 0);
    prv_compress_block(Y_mat, 0, types[0]);
    prv_compress_block(Cb_mat, 1, types[1]);
    prv_compress_block(Cr_mat, 2, types[2]);

    free_mat(Y_mat);
    free_mat(Cb_mat);
    free_mat(Cr_mat);
    free_mat(channels_mat);
}

/* Function is used to take an entire image and encode it into a .bin file
 * Currently, this uses dynamically allocated memory and should be changed to be entirely static once we know
 * what size our images will typically be */
void compress_image(Image *img){
    /* Generate YCbCr data from RGB input*/
    generate_ycbcr_data(img);

    /* Separate channels into Y Cb Cr in a 3 * (w*h) matrix */
    float **channels = calloc_mat(3, img->width*img->height);
    int index = 0;
    for(unsigned char *pg = img->YCbCr_data; pg != img->YCbCr_data + img->size; pg += img->channels, index++) {
        channels[0][index] = *pg;     // Y
        channels[1][index] = *(pg+1); // Cb
        channels[2][index] = *(pg+2); // Cr
    }

    /* Subsample Cb and Cr - LEAVE UNTIL LATER */
    /* This can probably be done by changing functionality from Y... Cb... Cr to Y, Cb, Cr, and skipping over
     * a few colour values at a time, and take care of the reconstruction in the decoder
    */

    /* Generate huffman codes given a table and its type
     * Currently, this function is passed standard tables that are defined in huff.c
     * As in improvement to this, custom huffman tables should be generated by first parsing through the whole image
     * and generating the tables */
    generate_huff_codes(&huffman_tables[LUM_DC_TABLE], LUM_DC_TABLE);
    generate_huff_codes(&huffman_tables[LUM_AC_TABLE], LUM_AC_TABLE);
    generate_huff_codes(&huffman_tables[COL_DC_TABLE], COL_DC_TABLE);
    generate_huff_codes(&huffman_tables[COL_AC_TABLE], COL_AC_TABLE);

    /* buf and nbit are statically declared and are used to write to the .bin file
     * fptr is the file pointer to write to */
    buf = 0;
    nbit = 0;
    fptr = fopen(FILE_OUT,"wb");

    /* Repeat the compression for each channel
     * This is not the JPEG standard way of encoding, typically the bitstream is read as Y Cb Cr (or slightly
     * differently if subsampled), this program instead codes each channel on its own, sending Y Y ... Y Cb .... Cb and
     * on. This could be changed later depending on the decoding process or the image loader we choose to use or make */
    // for 8x8 matrix in image
    int num_matricies = (img->height * img->width) / (BLOCK_SIZE * BLOCK_SIZE);
    float **YMatrix = calloc_mat(BLOCK_SIZE, BLOCK_SIZE);
    float **CbMatrix = calloc_mat(BLOCK_SIZE, BLOCK_SIZE);
    float **CrMatrix = calloc_mat(BLOCK_SIZE, BLOCK_SIZE);
    enum Type_t types[3] = {LUM, COL, COL};
    for (int m = 0; m < num_matricies; m++) {
        prv_array_to_matrix(YMatrix, &channels[0][m * 64], m);
        prv_array_to_matrix(CbMatrix, &channels[1][m * 64], m);
        prv_array_to_matrix(CrMatrix, &channels[2][m * 64], m);

        prv_compress_block(YMatrix, 0, types[0]);
        prv_compress_block(CbMatrix, 1, types[1]);
        prv_compress_block(CrMatrix, 2, types[2]);
//        printf("\nMCU #%d done\n", m+1);
//        if(m==10) exit(1);
    }
    flush_buffer(&buf, &nbit, fptr);

    free_mat(YMatrix);
    free_mat(CbMatrix);
    free_mat(CrMatrix);
    free_mat(channels);

    printf("\nDone after %d matrices\n", num_matricies);
}

void compression_exit(){
    flush_buffer(&buf, &nbit, fptr);
}

void prv_compress_block(float **Matrix, uint8_t channel, enum Type_t type){
    prv_block_dct(Matrix, BLOCK_SIZE, BLOCK_SIZE);
    prv_quantize(Matrix, type);
    prv_huffman_encode(Matrix, channel, type);
}

void prv_rgb_to_ycbcr(uint8_t *mcu_array){
    static uint8_t tmp_arr[BLOCK_SIZE*BLOCK_SIZE*IMG_CHANNELS] = { 0 };

    for(unsigned char *p = mcu_array, *pg = tmp_arr; p != mcu_array + (BLOCK_SIZE*BLOCK_SIZE*IMG_CHANNELS); p += IMG_CHANNELS, pg += IMG_CHANNELS) {
        *pg       = (uint8_t)( 0.257   * *p + 0.504  * *(p + 1) + 0.098   * *(p + 2)) + 16;          // Y
        *(pg + 1) = (uint8_t)(-0.148   * *p - 0.291  * *(p + 1) + 0.439   * *(p + 2)) + 128;         // Cb
        *(pg + 2) = (uint8_t)( 0.439   * *p - 0.368  * *(p + 1) - 0.071   * *(p + 2)) + 128;         // Cr
    }

    mcu_array = &tmp_arr[0];
}

void prv_block_dct(float **Matrix, int N, int M){
    float **tmpMatrix = calloc_mat(8, 8);
    float sum = 0, Cu, Cv;

    int i, j, u, v;
    for (u = 0; u < N; ++u) {
        for (v = 0; v < M; ++v) {
            sum = 0;
            for (i = 0; i < N; i++) {
                for (j = 0; j < M; j++) {
                    sum += Matrix[i][j] * cos(M_PI/((float)N)*(i+1./2.)*u)*cos(M_PI/((float)M)*(j+1./2.)*v);
                }
            }
            if (u==0) Cu=1/sqrt(2); else Cu=1;
            if (v==0) Cv=1/sqrt(2); else Cv=1;
            tmpMatrix[u][v] = 1/4.0*Cu*Cv*sum;
        }
    }

    for (int a = 0; a < 8; ++a) {
        for (int b = 0; b < 8; ++b) {
            Matrix[a][b] = tmpMatrix[a][b];
        }
    }

    free_mat(tmpMatrix);
}

void prv_quantize(float **Matrix, enum Type_t type){
    const float (*table)[8][8];
    if(type == LUM)
        table = &quantization_table;
    else
        table = &col_quantization_table;

    for (int i = 0; i < 8; ++i) {
        for (int j = 0; j < 8; ++j) {
            Matrix[i][j] = (int)(Matrix[i][j]/(*table)[i][j]);
        }
    }
}

void prv_huffman_encode(float **Matrix, uint8_t channel, enum Type_t type){
    static int prev_DC_Coeff[3] = { 0 };

    enum Table_t DC_Type;
    enum Table_t AC_Type;
    if(type == LUM) {
        DC_Type = LUM_DC_TABLE;
        AC_Type = LUM_AC_TABLE;
    } else {
        DC_Type = COL_DC_TABLE;
        AC_Type = COL_AC_TABLE;
    }

    int *output = calloc(64, sizeof(int));
    zig_zag_order(output, Matrix);

//    printf("\n");
//    for (int i = 0; i < 64; ++i) {
//        printf("%d, ", output[i]);
//    }
//    printf("\n");

//    printf("Encoding Channel %d, zig zag order:\n", channel);
//    for (int i = 0; i < 64; ++i) {
//        printf("%d, ", output[i]);
//    }
//    printf("\n\n");

    /* DC Coefficient */
    /* Edit the symbol to be relative to the previous symbol */
    uint16_t tmp = output[0];
    output[0] = output[0] - prev_DC_Coeff[channel];

//    printf("\n\n");
//    for (int i = 0; i < 64; ++i) {
//        printf("%d, ", output[i]);
//    }

    /* Fetch the length of the huffman symbol */
    uint8_t fetch_bit = (uint8_t)(floor(log2(abs(output[0]))) + 1);
    uint8_t sum_index = 0;
    uint8_t fetch_index = 0;
    // fetch_bit acts as the index of the symbol because dc symbols == index
    if(output[0] > 1) {
        while(sum_index < fetch_bit){
            sum_index += huffman_tables[DC_Type].offsets[fetch_index];
            fetch_index++;
        }
    } else {
        fetch_index = (type == LUM) ? 3: 2;
        fetch_bit = 1;
    }

    if(sum_index > fetch_bit) {
        fetch_index--;
    }

    // Write the DC huffman symbol, that is, the code for the length of the DC Coefficient
//    printf("Writing Symbol %X with len %d\n", fetch_bit, fetch_index);
    write_buffer(&buf, &nbit, fptr, huffman_tables[DC_Type].codes[fetch_bit], fetch_index);
    // Write the DC Coefficient itself
    if(output[0] < 0) output[0] = ~output[0];
    write_buffer(&buf, &nbit, fptr, (uint16_t)output[0], fetch_bit);
    prev_DC_Coeff[channel] = tmp;

    /* AC Coefficient */
    uint8_t zero_run = 0;
    for(int i = 1; i < 64; ++i){
        /*
         * For AC Coefficients, we need to keep track of the ZR (zero run), and encode the appropriate symbol
         * based on the ZR and the symbol that proceeds it.
         * This includes two special cases:
         * - 0xf0 is a run of 16 zeroes, or, a run of 15 zeroes proceeded by a zero
         * - 0x00 is the EOB, end of bytes for this block, or a run of zeroes until the end
        */
        if(output[i] == 0){
            zero_run++;
            continue;
        } else {
            while(zero_run >= 16) {
                write_buffer(&buf, &nbit, fptr, huffman_tables[AC_Type].codes[huffman_tables[AC_Type].ZRL_code_index], huffman_tables[AC_Type].ZRL_code_len);
                zero_run -= 16;
            }
            fetch_bit = (zero_run << 4);
            zero_run = 0;
            fetch_bit = fetch_bit | (uint8_t)(floor(log2(abs(output[i]))) + 1);
            /* Fetch an AC bit representation given the int or hex code */ // This is really slow should be fixed
            uint8_t index = 0;
            for(int j = 0; j < 162; ++j) {
                if(huffman_tables[AC_Type].symbols[j] == fetch_bit){
                    index = j;
                    break;
                }
            }
            /* Fetch the length of the huffman symbol */
            sum_index = 0;
            fetch_index = 0;
            // fetch_bit replaced with the index of the bit (see DC fetching) (add one to index to counter zero indexing)
            while(sum_index < index+1){
                sum_index += huffman_tables[AC_Type].offsets[fetch_index];
                fetch_index++;
            }
            fetch_index--;
            // Write Huffman Symbol (zr and coeff len)
//            printf("Writing Symbol %X index %d\n", huffman_tables[AC_Type].symbols[index], index);
            write_buffer(&buf, &nbit, fptr, huffman_tables[AC_Type].codes[index], fetch_index);
            // Write the AC Coeff itself
            if(output[i] < 0) output[i] = ~abs(output[i]);
            // last four bits of the fetch_bit represents the length in bits of the ac coefficient
            write_buffer(&buf, &nbit, fptr, (uint16_t)output[i], fetch_bit & 0b00001111);
        }
    }
    /* Write EOB to buffer*/
//    printf("Writing Symbol %X\n", huffman_tables[AC_Type].symbols[huffman_tables[AC_Type].EOB_code_index]);
    write_buffer(&buf, &nbit, fptr, huffman_tables[AC_Type].codes[huffman_tables[AC_Type].EOB_code_index], huffman_tables[AC_Type].EOB_code_len);

//    printf("\n");
    free(output);
}

void prv_array_to_matrix(float **matrix, const float *arr, int matrix_num)
{
    int i,j,k=0;
    for(i=0;i<8;i++)
    {
        for(j=0;j<8;j++)
        {
            matrix[i][j] = arr[k++];
        }
    }
}

